#pragma once
#include <windows.h>
#include <stdio.h>
#include <GL/glew.h>
#include <GL/wglew.h>
#include <GL/glext.h>
#include <GL/wglext.h>
#include <gl/gl.h>
#include <gl/glu.h>
#include "Vector.h"
#include "Tools.h"

#define		GL_MODEL_OK				0x00
#define		GL_MODEL_NOLIST			0x01
#define		GL_MODEL_NOSUCHFILE		0x02
#define		GL_MODEL_IOERROR		0x03
#define		GL_MODEL_NOMEMORY		0x04
#define		GL_MODEL_INVALIDFORMAT	0x04

class TMesh
{
	private:
	public:
		TMesh();
		~TMesh();
		GLuint VertexId;
		GLuint NormalId;
		float mat_ambient[3];
		float mat_diffuse[3];
		float mat_specular[3];
		float mat_shine[1];
		GLuint list_num;
		unsigned int Vertices;
		unsigned int NumIndex;
		unsigned int Faces;
		int LoadModel(char *filename);
		void Render(void);
};


/*
		http://www.codenet.ru/progr/cpp/spru/sscanf.php

		SCANF
            
            #include <stdio.h>
                                                                  
            int scanf(format-string[[, argument...]]);
            char *format-string.       строка управления форматом.
                                                                  
               Описание.
                                                                  
               Функция scanf читает данные из стандартного потока stdin  в
         место, определяемое аргументами arguments. Каждый аргумент должен
         быть  указателем на значение с типом, который соответствует типу,
         заданному в строке формата. Строка формата управляет преобразава-
         ниями полей ввода. Эта строка может содержать следующее:
            
               "Пробельные" символы, т.е. символ пробела ' ', табуляции \t,
         новой строки '\n'. Для функции scanf символом пробела определяет-
         ся считывание, но без запоминания, всех вводимых последующих сим-
         волов пробела вплоть до первого символа, не являющегося пробелом.
         
         При  вводе один символ пробела в строке формата соответствует лю-
         бому числу, включая 0, или любой комбинации символов пробела.
               Любой символ управления, не являющийся пробелом и  символом
         знака  процента %. Тогда по этому символу для функции scanf опре-
         деляется считывание, но без запоминания соответствующих  символов
         управления. Если следующий символ в <stdin> не соответствует сим-
         волам управления, то scanf оканчивает свою работу.
               Спецификацию  формата, введенную со знаком %. В этом случае
         scanf читает и преобразовывает введенные символы к значениям  за-
         данного типа, причем значения определяются соответствующими аргу-
         ментами из списка аргументов.
            
               Строка формата читается слева направо. Символы вне специфи-
         кации формата предполагаются согласованными с последовательностью
         символов в потоке stdin; эти согласованные символы в stdin скани-
         руются,  но  не  запоминаются.  Если  символ в stdin противоречит
         строке формата, scanf оканчивает свою работу. Этот  конфликтующий
         символ остается в stdin, так как он не может быть прочитан. Когда
         встречается  первая  спецификация формата, тогда значение первого
         поля ввода преобразовывается в соответствии со спецификацией фор-
         мата и запоминается в месте, заданном первым аргументом. По  вто-
         рой  спецификации формата выполняется преобразование второго поля
         ввода и запоминание его по второму  аргументу;  и  так  до  конца
         строки формата.
               Поле  ввода ограничивается первым "пробельным" символом или
         первым символом, который не может  преобразоваться  по  заданному
         формату, или случаем достижения поля width, которое идет первым.
               Если для выбранной спецификации формата задано больше аргу-
         ментов, чем требуется, то лишние аргументы игнорируются.
               Спецификация формата имеет следующую форму.

               %<flags><wigth><.precision><{F:N:h:I}><type>.
            
               Каждое  поле в формате спецификаций является отдельным сим-
         волом или числом,  выражающим  отдельную  опцию  формата.  Символ
         type, появляющийся после последнего необязательного поля формата,
         определяет тип поля ввода как символьного, строкового или числен-
         ного.
               Простейший формат спецификации содержит только символ знака
         процента и символ типа (например, %S).
               Каждое поле спецификации формата описывается ниже.
               Если  за  знаком  процента  % следует символ, не являющийся
         символом управления форматом, то этот символ и идущие за ним сим-
         волы, вплоть до следующего знака %, трактуются как обычная после-
         довательность символов, т.е. последовательность,  которая  должна
         быть введена. Например, чтобы ввести символ знака %, используется
         комбинация %%.
               Звездочка  (*),  идущая  за  знаком %, подавляет назначение
         следующего поля ввода, задающегося как поле,  определяемое  типом
         type. Это поле сканируется, но не запоминается.
               Widht  является  положительным десятичным целым и управляет
         максимально возможным числом символов, считываемых из stdin. Пре-
         образовываются и запоминаются по соответствующему аргументу толь-
         ко те символы, которые не превышают width. Если в width  встреча-
         ются  "пробельные"  символы,  т.е. символы пробела, табуляции или
         
         новой строки, то по выбранному формату они не  преобразовываются,
         пока не будет достигнут размер width.
               Необязательные  префиксы  F  и  N  не учитывают принятое по
         умолчанию адресное соглашение используемых моделей памяти. F  мо-
         жет  быть префиксом к аргументу argument, указыващему на far-объ-
         ект; а N - на near-объект.
               Необязательный префикс l свидетельствует о том, что исполь-
         зуется версия long; а префикс h - указывает на использование вер-
         сии  short.  Соответствующий  argument  указывает  на  long   или
         double-объект  (при  помощи префикса l)  или на short-объект (при
         помощи префикса h). Модификаторы l и h могут использоваться вмес-
         те с типами символов d, i, o, x, u. Модификатор l также может ис-
         пользоваться с символами type e и f. Если определен любой  другой
         type, модификаторы l и h игнорируются.
                
               Символы type и их значения описаны в таблице R.4.
            
                                                        Таблица R.4
               
                           Типы символов функции scanf
            
            СИМВОЛ    ПРЕДПОЛАГАЕМЫЙ ТИП        ТИП АРГУМЕНТА
                           ВВОДА
           
      
              d       десятичный   целый     указатель на  int.
                
              D       десятичный   целый     указатель на  long.
           
              o       восьмеричный целый     указатель на  int.
            
              O       восьмеричный целый     указатель на  long.
                                       
              x       шестнадцатеричный      указатель на  int.
                      целый
            
              X       шестнадцатеричный      указатель на  long.
                      целый
            
              i       десятичный,  вось-     указатель на  int.
                      меричный или шест-
                      надцатеричный  це-
                      лый
      
              I       десятичный,  вось-     указатель на  long.
                      меричный или шест-
                      надцатеричный  це-
                      лый
            
              u       беззнаковый  деся-     указатель на unsigned
                      тичный  целый          int.
                                        
              U       беззнаковый  деся-     указатель на unsigned
                      тичный  целый          long.
                                        
         
              e       значение с  плава-     указатель на  float
              f       ющей  точкой,  со-
                      держащее  необяза-
                      тельный знак ("+",
                      "-"),   одну   или
                      больше  десятичную
                      цифру, обычно  со-
                      держащую  десятич-
                      ную точку и экспо-
                      ненту ("е", "Е"),
                      которая    записы-
                      вается за знаковым
                      целым   значением.
                                        
              c       символьный. Симво-     указатель на  char
                      лы пробела,  табу-
                      ляции   или  новой
                      строки, так  назы-
                      ваемые "пробельные
                      символы",  которые
                      обычно  пропускают-
                      ся,  при   задании
                      этого типа  считы-
                      ваются. Для считы-
                      вания   следующего
                      символа, не являю-
                      щегося   "пробель-
                      ным", используется
                      комбинация %1s.
            
              s       строковый.             указатель на символь-
                                             ный массив, достаточ-
                                             но большой для вводи-
                                             мого  поля  вместе с
                                             нулевым     символом
                                             окончания '\0',  по-
                                             являющимся автомати-
                                             чески.
            
              n       чтение  при  вводе     указатель на  int, в
                      из   stream    или     котором записывается
                      буфера  не  проис-     число  успешно  счи-
                      ходит.                 танных  символов  из
                                             потока  или  буфера,
                                             вплоть до  указанных
                                             в вызове scanf.
                                              
              p       значение в   форме     указатель   на  far-
                      xxxx : yyyy,   где     группу данных.
                      цифры x и y  явля-
                      ются  шестнадцате-
                      ричными    цифрами
                      верхнего регистра.

            
         
               При  чтении  строк, не ограниченных символами пробела, мно-
         жество символов в квадратных скобках [] должно заменяться строко-
         вым типом s. Соответствующее поле ввода читается вплоть до перво-
         го символа, не содержащегося в ограниченном квадратными  скобками
         множестве символов. Если в этом множестве первым символом являет-
         ся  caret  (^),  результат сохраняется: поле ввода считывается до
         первого символа, не входящего в это множество символов. Чтобы за-
         помнить строку без нулевого символа '\0', применяется  специфика-
         ция %nc, где n - десятичное целое. В этом случае символьный тип s
         определяет  аргумент,  который указывает на массив символов. Сле-
         дующие  n  символов считываются из входного потока в определенное
         местоположение  и нулевой символ не записывается.
               Функция scanf для каждого поля ввода  сканирует  символ  за
         символом.  Она может окончить чтение отдельного поля при достиже-
         нии символа пробела, если либо достигнуто поле width; либо следу-
         ющий вводимый символ не может быть преобразован по заданному фор-
         мату; либо следующий символ  конфликтует  с  соответствующим  ему
         символом  в  управляющей строке формата; либо же следующий символ
         отсутствует в выбранном множестве символов. Когда происходит  вы-
         нужденный  процесс  окончания считывания, то следующее поле ввода
         рассматривается с самого  первого  конфликтующего  символа.  Этот
         символ, если он один, рассматривается как непрочитанный, либо как
         первый  символ  следующего  поля  ввода, либо как первый символ в
         последующих операциях чтения потока stdin.
            
               Возвращаемое значение.
            
               Эта функция возвращает число успешно преобразованных и наз-
         наченных полей. В возвращаемом значении не содержится число  про-
         читанных   но  не назначенных полей. При попытке считывания конца
         файла возвращается значение EOF. Возвращаемое значение 0 указыва-
         ет, что нет назначенных полей.
               См.  также  fscanf,  printf,  sscanf,  vfprintf,   vprintf,
         vsprintf.
            
               Пример 1.
            
            #include <stdio.h>
            
            int i;
            float fp;
            char c, s[81];
            
            scanf("%d  %f  %c  %s", &i, &fp, &c, s);
            
			ввод различных данных
            
            Пример 2.
            
            #include <stdio.h>
            
            main ()          преобразование шестнадцатеричного
                             ** или  восьмеричного   целого     к
                             ** десятичному целому
            {
            int numassigned, val;
         
            
            pintf("Enter hexadecimal or octal #, or 00
                   to guit:\n");
            do
               {  printf("# = ");
                  numassigned = scanf("%i", &val);
                  printf("Decimal # = %i\n", nal);
               }
            while (val && numassigned);
      
               конец  цикла,  если  значение  ввода равно 00, или если
         scanf не способна назначить поле
            
            }

               Тогда на выходе будет следующее.
            
            Enter hexadecimal or octal #, or 00 to guit:
                
            # = 0xf
            Decimal # = 15
                
            # = 0100
                
            Decimal # = 64
                
            # = 00
                
            Decimal # = 0.
*/